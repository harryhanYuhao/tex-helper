//! As we use recursive descent parsing, here we use recursive descent formatter
//! The major difficulty is two fold:
//! 1. the formatter shall be configurable
//! 1. The state of formatting shall be recorded. We can not have a purly recursively descent
//!    formatter as the parser, as sometimes the formated lines may change in order
//!
//! The is how we tackle the problem
//! Create a FormatState struct to record the state of formatting
//! Create a FormatRes struct to record the result of formatting
//!
//! For each node type, create a recursive formatting function just like the recursive descent
//! parser. Mutable FormatState and FormatRes are passed to each function
//!
//! The behaviour of each formatting function shall change with format state
//! At the end of the formatting, the result is generated from FormatRes (reordering as needed)
//!
//! If we are relying on recursion, for example format_bracket_arg will call format_recur, a new
//! format state and format res shall be created and passed to the recursive function, and the text
//! shall be generated by the modified FormatRes

use crate::latex_interpreter::ast::*;
use std::error::Error;

#[derive(Debug)]
struct FormatState {
    in_preamble: bool,

    line_width: usize,

    require_newline_before: bool,
    require_newline_after: bool,
}

impl FormatState {
    fn new() -> Self {
        FormatState {
            in_preamble: true,
            // This shall be configured
            line_width: 80,
            require_newline_before: false,
            require_newline_after: false,
        }
    }

    fn is_in_preamble(&self) -> bool {
        self.in_preamble
    }

    fn set_not_in_preamble(&mut self) {
        self.in_preamble = false;
    }

    fn require_newline_before(&self) -> bool {
        self.require_newline_before
    }

    fn require_newline_after(&self) -> bool {
        self.require_newline_after
    }

    fn from_line_width(line_width: usize) -> Self {
        FormatState {
            in_preamble: true,
            line_width,
            require_newline_before: false,
            require_newline_after: false,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Package {
    name: String,
    options: String, // options in square brackets
}

impl Package {
    fn new(name: String, options: String) -> Self {
        Package { name, options }
    }

    fn has_options(&self) -> bool {
        !self.options.is_empty()
    }

    fn get_name(&self) -> String {
        self.name.to_string()
    }

    fn get_options(&self) -> String {
        self.options.to_string()
    }
}

/// This struct is necessary, as formator will
#[derive(Debug)]
struct FormatRes {
    preamble_before_use_package: String,
    used_packages: Vec<Package>,
    preamble_after_use_package: String,

    main_text: String,
}

impl FormatRes {
    fn empty() -> Self {
        FormatRes {
            preamble_before_use_package: String::new(),
            used_packages: vec![],
            preamble_after_use_package: String::new(),
            main_text: String::new(),
        }
    }

    fn to_string(&self) -> String {
        let mut res = String::new();
        res.push_str(&self.preamble_before_use_package);

        // TODO: there shall be configurable behaviours
        for pkg in &self.used_packages {
            if pkg.has_options() {
                res.push_str(&format!(
                    "\\usepackage[{}]{{{}}}\n",
                    pkg.get_options(),
                    pkg.get_name()
                ));
            } else {
                res.push_str(&format!("\\usepackage{{{}}}\n", pkg.get_name()));
            }
        }
        res.push_str(&self.preamble_after_use_package);
        res.push_str(&self.main_text);
        res
    }

    fn to_vec_string(&self) -> Vec<String> {
        let string = self.to_string();
        let string = string.replace("\n", "\n");
        let string = string.split("\n");
        string.map(|s| s.to_string()).collect()
    }

    /// Note, if one package is added multiple times, each with different options, those with
    /// distinct options are all added.
    ///
    /// Compiler only avoid complete duplicates: that is, exact same package name with exact
    /// same options
    fn add_package(&mut self, pkg: Package) {
        if !self.used_packages.contains(&pkg) {
            self.used_packages.push(pkg);
        }
    }
}

// Recall the definitiion of NodeType below:
//enum NodeType {
//    Passage, // A passage consisists of many paragraphs
//    Paragraph, // A paragraph consists of many Words, operations, etc
//    Word,
//    Operation, // parsing a^b a_c
//    Ampersand, // & are used for alignment in Latex
//    DoubleBackSlash, //  \\
//
//    Command,
//    CurlyBracketArg, // {para}
//    SquareBracketArg,
//
//    InlineMath,
//    DisplayMath,
//
//    Envr, // environment
//
//    Comment,
//}
//
// Note::
// The root of AST is always a Passage node
// The Passage node contains many Paragraph nodes
// Passage and paragraph nodes are for structuring and not contain any text by themselves
//
pub fn format(ast: NodePtr) -> Result<String, Box<dyn Error>> {
    let mut state = FormatState::from_line_width(80);
    let mut res = FormatRes::empty();

    format_recur(ast, &mut state, &mut res)?;

    Ok(res.to_string())
}

fn format_recur(
    node: NodePtr,
    state: &mut FormatState,
    res: &mut FormatRes,
) -> Result<(), Box<dyn Error>> {
    match Node::get_node_type_nodeptr(node.clone()) {
        NodeType::Passage => {
            format_passage(node.clone(), state, res)?;
        }
        NodeType::Paragraph => {
            format_paragraph(node.clone(), state, res)?;
        }
        NodeType::CurlyBracketArg => {
            format_curly_bracket_arg(node.clone(), state);
        }
        NodeType::SquareBracketArg => {
            format_square_bracket_arg(node.clone(), state);
        }
        NodeType::InlineMath => {
            format_inline_math(node.clone(), state);
        }
        NodeType::DisplayMath => {
            format_display_math(node.clone(), state);
        }
        NodeType::Envr => {
            format_envr(node.clone(), state);
        }
        NodeType::Command => {
            format_command(node.clone(), state);
        }
        NodeType::Operation => {
            format_operation(node.clone(), state);
        }
        _ => {
            panic!(
                "Internal Error! format_recur: Unexpected node type {:?}",
                Node::get_node_type_nodeptr(node.clone())
            );
        }
    };
    Ok(())
}

/// Whenever encountering a NewParagraph token, a new paragraph node will be created
/// A NewParagraph token is created when there is two or more consecutive newlines with only empty
/// chars between them
/// So the following will be parsed into
/// ```
/// \begin{document}
///
/// \maketitle
/// \end{document}
/// ```
/// Parsed result
///Passage()
///└── Paragraph()
///    └── Envr(document)
///        └── Passage()
///            ├── Paragraph()
///            └── Paragraph()
///                └── Command(maketitle)
fn format_passage(
    node: NodePtr,
    state: &mut FormatState,
    res: &mut FormatRes,
) -> Result<(), Box<dyn Error>> {
    let node = node.lock().unwrap();
    let children = node.get_children();
    for c in children {
        match Node::get_node_type_nodeptr(c.clone()) {
            NodeType::Paragraph => {
                format_paragraph(c.clone(), state, res)?;
            }
            _ => {
                panic!(
                    "Unexpected node type in passage: {:?}",
                    c.lock().unwrap().node_type
                );
            }
        }
    }
    Ok(())
}

/// This function shall only be called when processing usepackage command in preamble
/// The input must be a node with type Command and lexeme "usepackage"
/// This function modifies FormatRes to record the used packages.
/// When formatting is done, the string will be generated from FormatRes
//
// TODO: check if the package name is valid
//
// Note there are two forms of usepackage command:
// \usepackage{pkg1, pkg2}
// \usepackage[options]{pkg1, pkg2}
// Both are handled by the pacakge struct
//
fn process_usepackage(
    node: NodePtr,
    res: &mut FormatRes,
) -> Result<(), Box<dyn Error>> {
    let node = node.lock().unwrap();
    let children = node.get_children();
    match children.len() {
        0 => {
            panic!("Internal Error! process_usepackege: usepackage command has no arguments");
        }
        1 => {
            // Only one argument, must be curly bracket arg
            let arg = children[0].clone();
            if Node::get_node_type_nodeptr(arg.clone())
                != NodeType::CurlyBracketArg
            {
                panic!("Internal Error! process_usepackege: usepackage command has invalid argument");
            }

            // arg is a curly bracket arg
            let arg_content = Node::get_children_string_lexeme_ptr(arg.clone());
            let pkgs: Vec<Package> = arg_content
                .split(',')
                .map(|s| Package::new(s.trim().to_string(), String::new()))
                .collect();
            for pkg in &pkgs {
                res.add_package(pkg.clone());
            }
        }
        2 => {
            // Two arguments, first must be square bracket arg, second must be curly bracket arg
            let options = children[0].clone();
            let packages = children[1].clone();
            if Node::get_node_type_nodeptr(options.clone())
                != NodeType::SquareBracketArg
            {
                panic!("Internal Error! process_usepackege: usepackage command has invalid first argument");
            }
            if Node::get_node_type_nodeptr(packages.clone())
                != NodeType::CurlyBracketArg
            {
                panic!("Internal Error! process_usepackege: usepackage command has invalid second argument");
            }

            let options = Node::get_children_string_lexeme_ptr(options.clone());
            let arg_content =
                Node::get_children_string_lexeme_ptr(packages.clone());
            let pkgs: Vec<Package> = arg_content
                .split(',')
                .map(|s| Package::new(s.trim().to_string(), options.clone()))
                .collect();
            for pkg in &pkgs {
                res.add_package(pkg.clone());
            }
        }
        _ => {}
    }
    Ok(())
}

fn format_paragraph(
    node: NodePtr,
    state: &mut FormatState,
    res: &mut FormatRes,
) -> Result<(), Box<dyn Error>> {
    let node = node.lock().unwrap();
    for c in node.get_children() {
        match Node::get_node_type_nodeptr(c.clone()) {
            NodeType::Paragraph => {}
            NodeType::Command => {
                let lexeme = Node::lexeme_from_nodeptr(c.clone());
                if lexeme == "usepackage" {
                    if !state.is_in_preamble() {
                        // TODO: Error handling (Just delete the command not in the preamble?)
                        panic!("Error: usepackage command found after the preamble");
                    }
                    process_usepackage(c.clone(), res)?;
                } else {
                    let ret = format_command(c.clone(), state);
                }
            }
            _ => {
                panic!(
                "Internal Error! format_paragraph: Expecting NodeType Paragraph, found {:?}",
                Node::get_node_type_nodeptr(c.clone())
            );
            }
        }
    }
    Ok(())
}

fn format_curly_bracket_arg(
    node: NodePtr,
    state: &mut FormatState,
) -> Vec<String> {
    if Node::get_node_type_nodeptr(node.clone()) != NodeType::CurlyBracketArg {
        panic!("Internal Error! format_curly_bracket_arg: Expecting NodeType CurlyBracketArg, found {:?}", Node::get_node_type_nodeptr(node.clone()));
    }
    let res = Node::get_lexeme_recur_ptr(node);

    vec![res]
}

fn format_square_bracket_arg(
    node: NodePtr,
    state: &mut FormatState,
) -> Vec<String> {
    if Node::get_node_type_nodeptr(node.clone()) != NodeType::SquareBracketArg {
        panic!("Internal Error! format_curly_bracket_arg: Expecting NodeType SquareBracketArg, found {:?}", Node::get_node_type_nodeptr(node.clone()));
    }
    let res = Node::get_lexeme_recur_ptr(node);

    vec![res]
}

fn format_inline_math(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_display_math(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_envr(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_command(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_operation(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}
