//! As we use recursive descent parsing, here we use recursive descent formatter
//! The major difficulty is two fold:
//! 1. the formatter shall be configurable 
//! 1. The state of formatting shall be recorded. We can not have a purly recursively descent
//!    formatter as the parser, as sometimes the formated lines may change in order 
//!
//! The is how we tackle the problem
//! Create a FormatState struct to record the state of formatting
//! Create a FormatRes struct to record the result of formatting
//! 
//! For each node type, create a recursive formatting function just like the recursive descent
//! parser. Mutable FormatState and FormatRes are passed to each function
//!
//! The behaviour of each formatting function shall change with format state 
//! At the end of the formatting, the result is generated from FormatRes (reordering as needed)
//!
//! If we are relying on recursion, for example format_bracket_arg will call format_recur, a new
//! format state and format res shall be created and passed to the recursive function, and the text
//! shall be generated by the modified FormatRes
use crate::latex_interpreter::ast::*;

#[derive(Debug)]
struct FormatState {
    in_preamble: bool,

    line_width: usize,

    require_newline_before: bool,
    require_newline_after: bool,
}

impl FormatState {
    fn new() -> Self {
        FormatState {
            in_preamble: true,
            // This shall be configured
            line_width: 80,
            require_newline_before: false,
            require_newline_after: false,
        }
    }

    fn is_in_preamble(&self) -> bool {
        self.in_preamble
    }

    fn set_not_in_preamble(&mut self) {
        self.in_preamble = false;
    }

    fn require_newline_before(&self) -> bool {
        self.require_newline_before
    }

    fn require_newline_after(&self) -> bool {
        self.require_newline_after
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Package {
    name: String,
    options: String, // options in square brackets
}

impl Package {
    fn new(name: String, options: String) -> Self {
        Package { name, options }
    }
}

/// This struct is necessary, as formator will
#[derive(Debug)]
struct FormatRes {
    preamble_before_use_package: String,
    used_packages: Vec<Package>,
    preamble_after_use_package: String,

    main_text: String,
}

impl FormatRes {
    fn empty() -> Self {
        FormatRes {
            preamble_before_use_package: String::new(),
            used_packages: vec![],
            preamble_after_use_package: String::new(),
            main_text: String::new(),
        }
    }

    fn to_string(&self) -> String {
        let mut res = String::new();
        res.push_str(&self.preamble_before_use_package);

        // TODO: there shall be configurable behaviours
        // for pkg in &self.used_packages {
        //     res.push_str(&format!("\\usepackage{{{}}}\n", pkg));
        // }
        res.push_str(&self.preamble_after_use_package);
        res.push_str(&self.main_text);
        res
    }

    fn to_vec_string(&self) -> Vec<String> {
        let string = self.to_string();
        let string = string.replace("\n", "\n");
        let string = string.split("\n");
        string.map(|s| s.to_string()).collect()
    }
}

// Recall the definitiion of NodeType below:
//enum NodeType {
//    Passage, // A passage consisists of many paragraphs
//    Paragraph, // A paragraph consists of many Words, operations, etc
//    Word,
//    Operation, // parsing a^b a_c
//    Ampersand, // & are used for alignment in Latex
//    DoubleBackSlash, //  \\
//
//    Command,
//    CurlyBracketArg, // {para}
//    SquareBracketArg,
//
//    InlineMath,
//    DisplayMath,
//
//    Envr, // environment
//
//    Comment,
//}
//
// Note::
// The root of AST is always a Passage node
// The Passage node contains many Paragraph nodes
// Passage and paragraph nodes are for structuring and not contain any text by themselves
//
/// Format does not return error, as it assumes the AST is valid
/// Any errors from this function is a bug
pub fn format(ast: NodePtr) -> String {
    let mut state = FormatState::new();
    let mut res = FormatRes::empty();

    format_recur(ast, &mut state, &mut res);

    res.to_string()
}

fn format_recur(
    node: NodePtr,
    state: &mut FormatState,
    res: &mut FormatRes,
) -> Vec<String> {
    match Node::get_node_type_nodeptr(node.clone()) {
        NodeType::Passage => {
            format_passage(node.clone(), state, res);
        }
        NodeType::Paragraph => {
            format_paragraph(node.clone(), state, res);
        }
        NodeType::CurlyBracketArg => {
            format_curly_bracket_arg(node.clone(), state);
        }
        NodeType::SquareBracketArg => {
            format_square_bracket_arg(node.clone(), state);
        }
        NodeType::InlineMath => {
            format_inline_math(node.clone(), state);
        }
        NodeType::DisplayMath => {
            format_display_math(node.clone(), state);
        }
        NodeType::Envr => {
            format_envr(node.clone(), state);
        }
        NodeType::Command => {
            format_command(node.clone(), state);
        }
        NodeType::Operation => {
            format_operation(node.clone(), state);
        }
        _ => {
            panic!(
                "Internal Error! format_recur: Unexpected node type {:?}",
                Node::get_node_type_nodeptr(node.clone())
            );
        }
    };
    vec![]
}

fn format_passage(node: NodePtr, state: &mut FormatState, res: &mut FormatRes) {
    let node = node.lock().unwrap();
    let children = node.get_children();
    for c in children {
        match Node::get_node_type_nodeptr(c.clone()) {
            NodeType::Paragraph => {
                format_paragraph(c.clone(), state, res);
            }
            _ => {
                panic!(
                    "Unexpected node type in passage: {:?}",
                    c.lock().unwrap().node_type
                );
            }
        }
    }
}

/// This function shall only be called when processing usepackage command in preamble
/// The input must be a node with type Command and lexeme "usepackage"
/// This function modifies state to record the used packages. 
/// When formatting is done, the string will be generated from FormatRes
//
// TODO: check if the package name is valid
//
// Note there are two forms of usepackage command:
// \usepackage{pkg1, pkg2}
// \usepackage[options]{pkg1, pkg2}
// Both are handled by the pacakge struct
//
fn process_usepackage(node: NodePtr, res: &mut FormatRes) -> Vec<Package> {
    let node = node.lock().unwrap();
    let children = node.get_children();
    match children.len() {
        0 => {
            panic!("Internal Error! process_usepackege: usepackage command has no arguments");
        }
        1 => {
            // Only one argument, must be curly bracket arg
            let arg = children[0].clone();
            if Node::get_node_type_nodeptr(arg.clone())
                != NodeType::CurlyBracketArg
            {
                panic!("Internal Error! process_usepackege: usepackage command has invalid argument");
            }
            let arg_content =
                format_curly_bracket_arg(arg.clone(), &mut FormatState::new())
                    [0]
                .clone();
            let pkgs: Vec<Package> = arg_content
                .split(',')
                .map(|s| Package::new(s.trim().to_string(), String::new()))
                .collect();
            return pkgs;
        }
        2 => {
            // Two arguments, first must be square bracket arg, second must be curly bracket arg
            let arg1 = children[0].clone();
            let arg2 = children[1].clone();
            if Node::get_node_type_nodeptr(arg1.clone())
                != NodeType::SquareBracketArg
            {
                panic!("Internal Error! process_usepackege: usepackage command has invalid first argument");
            }
            if Node::get_node_type_nodeptr(arg2.clone())
                != NodeType::CurlyBracketArg
            {
                panic!("Internal Error! process_usepackege: usepackage command has invalid second argument");
            }

            let options = format_square_bracket_arg(
                arg1.clone(),
                &mut FormatState::new(),
            )[0]
            .clone();
            let arg_content =
                format_curly_bracket_arg(arg2.clone(), &mut FormatState::new())
                    [0]
                .clone();
            let pkgs: Vec<Package> = arg_content
                .split(',')
                .map(|s| Package::new(s.trim().to_string(), options.clone()))
                .collect();
            return pkgs;
        }
        _ => {}
    }

    vec![]
}

fn format_paragraph(
    node: NodePtr,
    state: &mut FormatState,
    res: &mut FormatRes,
) {
    let node = node.lock().unwrap();
    for c in node.get_children() {
        match Node::get_node_type_nodeptr(c.clone()) {
            NodeType::Paragraph => {}
            NodeType::Command => {
                let lexeme = Node::lexeme_from_nodeptr(c.clone());
                if lexeme == "usepackage" {
                    if !state.is_in_preamble() {
                        // TODO: Error handling (May be just delete the command
                        // not in the preamble)
                        panic!("Error: usepackage command found after the preamble");
                    }
                    process_usepackage(c.clone(), res);
                } else {
                    let ret = format_command(c.clone(), state);
                }
            }
            _ => {
                panic!(
                "Internal Error! format_paragraph: Expecting NodeType Paragraph, found {:?}",
                Node::get_node_type_nodeptr(c.clone())
            );
            }
        }
    }
}

pub fn format_curly_bracket_arg(
    node: NodePtr,
    state: &mut FormatState,
) -> Vec<String> {
    if Node::get_node_type_nodeptr(node.clone()) != NodeType::CurlyBracketArg {
        panic!("Internal Error! format_curly_bracket_arg: Expecting NodeType CurlyBracketArg, found {:?}", Node::get_node_type_nodeptr(node.clone()));
    }
    let res = Node::get_string_content_recur_nodeptr(node);

    vec![res]
}

fn format_square_bracket_arg(
    node: NodePtr,
    state: &mut FormatState,
) -> Vec<String> {
    if Node::get_node_type_nodeptr(node.clone()) != NodeType::SquareBracketArg {
        panic!("Internal Error! format_curly_bracket_arg: Expecting NodeType SquareBracketArg, found {:?}", Node::get_node_type_nodeptr(node.clone()));
    }
    let res = Node::get_string_content_recur_nodeptr(node);

    vec![res]
}

fn format_inline_math(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_display_math(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_envr(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_command(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}

fn format_operation(node: NodePtr, state: &mut FormatState) -> Vec<String> {
    vec![]
}
